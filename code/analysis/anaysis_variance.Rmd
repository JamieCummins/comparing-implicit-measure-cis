---
title: "Comparing the variances of different implicit measures"
author: "Ian Hussey & Jamie Cummins"
output:
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

# TODO

- NA

# Arugment:

decent measure needs three properties: (1) can detect unambiguous preferences (preference for self over others), (2) some degree of variance 

```{r include=FALSE}

# formatting options
# set default chunk options
knitr::opts_chunk$set(message = FALSE, 
                      warning = FALSE)

# disable scientific notation
options(scipen = 999) 

# knitr output for html
options(knitr.table.format = "html")

```

# Dependencies & options

```{r}

# dependencies
library(tidyverse)
library(broom)
library(knitr)
library(kableExtra)
library(ggsignif)
library(rstatix)
library(lavaan)

format_p_value <- function(p){
  p_formatted <- ifelse(p >= 0.001, round(p, 3),
                        ifelse(p < 0.001, "< .001", NA))
  p_formatted <- gsub(pattern = "0.", replacement = ".", x = p_formatted, fixed = TRUE)
  return(p_formatted)
}

round_df <- function(x, ndigits = 3) {
  mutate_if(x, is.numeric, janitor::round_half_up, digits = ndigits)
}

```

# Data

```{r}

data_processed <- read_rds("../../data/processed/data_processed.rds") |>
  rename(subject = session_id) |>
  mutate(measure = fct_relevel(toupper(measure), "IAT", "BIAT", "SIAT", "AMP", "GNAT", "EPT"),
         estimate_absolute = abs(estimate))

data_processed_wide <- data_processed |>
  select(subject, domain, measure, estimate) |>
  arrange(domain, measure) |>
  pivot_wider(names_from = c("domain", "measure"),
              values_from = estimate)

```

# Correlations

```{r}

data_processed_wide |>
  select(-subject) |>
  cor(method = "spearman", use = "pairwise.complete.obs") |>
  round(2)

```

# Analysis of variances between measures and domains

## Distributions

```{r}

data_processed %>%
  group_by(domain, measure) %>%
  do(tidy(t.test(x = .$estimate, mu = 0.50))) |>
  round_df(4) |>
  select(domain, measure, estimate, conf.low, conf.high, p.value)

# data_processed %>%
#   group_by(measure, domain) %>%
#   do(tidy(t.test(x = .$estimate_absolute))) |>
#   round_df(4) |>
#   select(measure, domain, estimate, conf.low, conf.high, p.value)

```

```{r}

ggplot(data_processed, aes(estimate)) +
  geom_vline(xintercept = 0.5, linetype = "dotted") +
  geom_density(adjust = 2, alpha = 0.3) +
  facet_grid(measure ~ domain, scales = "free_y")

# ggplot(data_processed, aes(estimate_absolute)) +
#   geom_vline(xintercept = 0.5, linetype = "dotted") +
#   geom_density(adjust = 2, alpha = 0.3) +
#   facet_grid(measure ~ domain, scales = "free_y")

```

## Compare variances between domains for each measure

F test vs Levene's test:

- F test can only be used to compare two variances, whereas Levene's test can compare multiple factors (i.e. can provide an omnibus test).
- F test makes strict assumption of normality which will likely be violated for AMP data. However, one could argue that this assumption is not ours but common to the analysis of AMP data in the literature?
- F test benefits from providing estimates of effect size (i.e., the ratio between the samples' variances). This can be used to speak to magnitudes of differences, and compare the three measures. However, this relies on the assumption of normality which is likely to be violated for the AMP data.

Analytic strategy given pros and cons of each:

1. An omnibus Levene's test will be used to test for differences between measures * domains. 
2. Follow-up Levene's tests will compare domains for each measure and measures for each domain. These will be used for hypothesis tests:
  - The validity of each measure as a measures of evaluations relies on it demonstrating differences between the domains.
3. F tests will compare domains for each measure. 
  - The confidence intervals for each measure will be used to infer the relative validity of each measure as a measure of evaluations. 

### Levene's test

I.e., absolute values of the deviations from the median. Levene's original test uses the mean, and this more robust version using the median is technically the Brown-Forsythe test. However, this name is less well known, and Levene's test is often a catchall (including in the function name).

##### Omnibus test to compare measures*domains

```{r}

data_processed |>
  car::leveneTest(estimate ~ domain * measure, 
                  data = _, 
                  centre = median) |>
  tidy()

```

#### Follow-up tests to compare measures within each domain

```{r}

results_levenes_test_by_domain <- data_processed |> 
  group_by(domain) |>
  do(broom::tidy(car::leveneTest(estimate ~ measure, data = ., center = median))) |>
  mutate(statistic = janitor::round_half_up(statistic, 2)) |>
  select(domain, statistic, df, df_residual = df.residual, p = p.value) |>
  add_significance(p.col = "p")

results_levenes_test_by_domain

```


#### Table of variances by domain and measure

```{r}

data_processed |> 
  group_by(domain, measure) |>
  summarize(var = round(var(estimate), 3)) |>
  pivot_wider(names_from = domain,
              values_from = var)

```

#### Plot of variances by domain and measure

```{r}

# data wrangling
data_summary <- data_processed |>
  group_by(measure, domain) |>
  summarize(mean = mean(estimate),
            sd = sd(estimate),
            variance = var(estimate),
            .groups = "drop")

# plot
p1 <-
  ggplot(data_summary, aes(x = measure, y = variance, fill = domain)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  ylab("Variance") +
  theme_bw() +
  theme(legend.position = "right") +
  scale_fill_viridis_d(begin = 0.3,
                       end = 0.7,
                       name = "Domain") +
  scale_x_discrete(name = "Measure")

p1 
# + 
#   geom_signif(xmin = c(0.78, 1.78, 2.78), 
#               xmax = c(1.22, 2.22, 3.22), 
#               y_position = 0.088,
#               tip_length = .02, 
#               # annotation = format_p_value(results_levenes_test_pairwise$p)) +
#               annotation = results_levenes_test_pairwise$p.signif) +
#   coord_cartesian(ylim = c(0, 0.09))

```

### Using F tests to compare domains pairwise

We don't attempt to address the ratio of true variance to error variance within any measure/domain, just examine the relative amount of variance between measures and domains. Some systematic differences between domains is useful though, which we explore here:

```{r}

compare_variances_domain <- function(dat, domain_1, domain_2){
  
  dat |> 
    filter(domain %in% c(domain_1, domain_2)) |>
    group_by(measure) |>
    do(broom::tidy(var.test(estimate ~ domain, data = .))) |>
    mutate(domain_1 = domain_1,
           domain_2 = domain_2) |>
    select(domain_1, domain_2, 
           measure, method, estimate, ci_lower = conf.low, ci_upper = conf.high, 
           statistic, df_numerator = num.df, denominator_df = den.df, p = p.value) 
  
}

results_f_test <- 
  bind_rows(
    compare_variances_domain(data_processed, "politics", "self"),
    compare_variances_domain(data_processed, "politics", "race"),
    compare_variances_domain(data_processed, "race", "self")
  ) |>
  mutate(p_adjusted = p.adjust(p, "holm")) |>
  rstatix::add_significance(p.col = "p_adjusted") |>
  #select(domain_1, domain_2, measure, p_adjusted.signif) |>
  arrange(measure) |>
  mutate(domains = paste(domain_1, domain_2, sep = " / "))

results_f_test

```

```{r}

# ggplot(results_f_test, aes(fct_rev(measure), estimate, group = domains)) +
#   geom_hline(yintercept = 1, linetype = "dotted") +
#   geom_linerange(aes(ymin = ci_lower, ymax = ci_upper),
#                  position = position_dodge(width = 0.3)) +
#   geom_point(position = position_dodge(width = 0.3)) +
#   coord_flip() +
#   xlab("measure") +
#   ylab("Variance ratio") +
#   theme_bw()
#   # scale_x_discrete(labels = c("IAT" = "IAT", 
#   #                             "AMP" = "AMP",
#   #                             "SR" = "Self report"))

ggplot(results_f_test, aes(fct_rev(measure), estimate)) +
  geom_hline(yintercept = 1, linetype = "dotted") +
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper)) +
  geom_point() +
  coord_flip() +
  xlab("Measure") +
  ylab("Variance ratio") +
  theme_bw() +
  facet_wrap(~ domains)

```

### Using F tests to compare measures pairwise

```{r}

compare_variances <- function(dat, measure_1, measure_2){
  
  dat |> 
    filter(measure %in% c(measure_1, measure_2)) |>
    group_by(domain) |>
    do(broom::tidy(var.test(estimate ~ measure, data = .))) |>
    mutate(measure_1 = measure_1,
           measure_2 = measure_2) |>
    select(measure_1, measure_2, 
           domain, method, estimate, ci_lower = conf.low, ci_upper = conf.high, 
           statistic, df_numerator = num.df, denominator_df = den.df, p = p.value) 
  
}

results_f_test <- 
  bind_rows(
    compare_variances(data_processed, "IAT", "AMP"),
    compare_variances(data_processed, "IAT", "GNAT"),
    compare_variances(data_processed, "IAT", "EPT"),
    
    compare_variances(data_processed, "AMP", "IAT"),
    compare_variances(data_processed, "AMP", "GNAT"),
    compare_variances(data_processed, "AMP", "EPT"),
    
    compare_variances(data_processed, "GNAT", "IAT"),
    compare_variances(data_processed, "GNAT", "AMP"),
    compare_variances(data_processed, "GNAT", "EPT"),
    
    compare_variances(data_processed, "GNAT", "IAT"),
    compare_variances(data_processed, "GNAT", "AMP"),
    compare_variances(data_processed, "GNAT", "EPT")
  ) |>
  mutate(p_adjusted = p.adjust(p, "holm")) |>
  rstatix::add_significance(p.col = "p_adjusted") |>
  select(measure_1, measure_2, domain, p_adjusted.signif)

results_f_test

```


